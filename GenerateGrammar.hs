module GenerateGrammar where

import System.Environment (getArgs)
import System.Exit
import System.FilePath.Posix
import System.Timeout
import Data.List
import Data.Maybe
import Data.Char
import PGF
import BuildGFGrammar
import UD2GF
import UDAnnotations
import RTree
import UDConcepts
import GFConcepts

main = do
    argv <- getArgs
    case argv of
        -- args should be the extraction grammar + the morphodicts + the conllu file (in this order)
        (pr:dcs) -> do 
            let ds = -- paths to morphodicts
                    takeWhile isPfg dcs 
            let cs = -- paths to aligned (by id) .conllu files
                    dropWhile isPfg dcs
            let gr = pr ++ ".pgf"
            -- read grammars and conllu files
            gr' <- readPGF gr
            ds' <- mapM readPGF ds
            cs' <- mapM parseUDFile cs
            -- discard concepts not instantiated in all languages
            let cs'' = getAlignments cs'
            -- TODO: language order can be a problem, is it alphabetical...?
            -- TODO: it uses all langs of the pgf grammar...
            let langs = map (reverse . take 3 . reverse . showLanguage) (languages gr')
            --print langs
            -- create UD environments (one per language)
            envs <- mapM (flip (getEnv pr) "Utt") langs
            -- associate envs (langs) to lists of UD sentences
            let ecs = envs `zip` cs'' :: [(UDEnv, [UDSentence])]
            -- transform UD sentences into (LISTS OF, cf. uds2ast) ASTs, 
            -- translation equivalents are on the same row
            as <- mapM (\(e,ss) -> mapM (uds2astTimed 1 e) ss) ecs
            let langNotes = map (++ ": ") langs
            let aas = map (zip langNotes) (transpose as)
            -- cf. $paste out/gfts-en.tmp out/gfts-it.tmp but with additional formatting required by BuildGrammar
            let stras = map (intercalate "\n" . map (\(a,ts) -> a ++ concatMap prAbsTree ts)) aas
            -- cf. $grep -v Backup | sort -u 
            let stras' = intersperse "\n" $ sort $ nub $ filter (not . isInfixOf "Backup") stras
            -- putStrLn stras' -- just because "se non vedo non credo" 
            -- filter out trees containing weird characters and numbers
            let stras'' = filter (all isAlpha') stras' 
            buildGFGrammar gr ds (unlines stras'')
        _ -> putStrLn usage >> exitWith (ExitFailure 1)  
    where
        isPfg p = takeExtension p == ".pgf"
        isAlpha' c = or [isAlpha c, c == ' ', c == '\n', c == '_', c == ':', c == '(', c == ')']

-- | Given n lists of UD sentences obtained via CP and/or CE (in general, with 
-- aligned by sent_id), only get the concepts found in all n langs (so that
-- the lists in the resulting sentences are also aligned implicitly) 
getAlignments :: [[UDSentence]] -> [[UDSentence]]
getAlignments sss =  
    transpose $ mapMaybe getAlignment [(offs + 1)..(offs + maximum (map length sss))]
        where
            getAlignment :: Int -> Maybe [UDSentence]
            getAlignment i = 
                let as = map (find (\s -> sentId s == i)) sss
                in if all isJust as then Just $ map fromJust as else Nothing
            offs = 1000000 -- numbering offset (cf. prUDSentence in UDConcepts)

-- | Return the id of a sentence, taken from the comment that precedes it
sentId :: UDSentence -> Int
-- assumption: the CoNLL-U files are generated by ExtractConcepts and
-- PropagateConcepts and have not been modified
sentId = read . drop 4 . last . words . head . udCommentLines

-- | Convert a UD sentence into the best corresponding GF ASTs via gfud 
-- functions (a more general function of this kind should REALLY belong to 
-- gfud!)
-- (NOTE: not used cause ud2gf tends to eat up all memory by getting stuck
-- on specific trees)
uds2ast :: UDEnv -> UDSentence -> [AbsTree] 
uds2ast env uds = map (expandMacro env) (devtree2abstrees 
                                    $ addBackups            
                                    $ head                  
                                    $ splitDevTree          
                                    $ combineTrees env
                                    $ analyseWords env
                                    $ udtree2devtree
                                    $ simpleRoot
                                    $ udSentence2tree uds)

-- to ignore any kind of weird label/subtype in the output of CA
simpleRoot :: UDTree -> UDTree
simpleRoot (RTree n ts) = RTree (n { udDEPREL = "root"}) ts

-- | Timed version of uds2ast
uds2astTimed :: Int -> UDEnv -> UDSentence -> IO [AbsTree]
uds2astTimed ms env uds = do
    r <- timeout ms (uds2ast' env uds)
    case r of
        Just as -> return as
        Nothing -> return []
    where 
        uds2ast' :: UDEnv -> UDSentence -> IO [AbsTree]
        uds2ast' env uds = return $ uds2ast env uds

usage :: String
usage = "Usage: stack exec -- GenerateGrammar " 
     ++ "path_to_extract_grammar paths_to_morphodicts paths_to_aligned_conllu_files"
     ++ "\n\n(NOTE: grammars, incl. morphodicts, should be in .pgf format. " 
     ++ "The .conllu files for the various langs need be in the same "
     ++ "order ad the .pgf files for the morphodicts. "
     ++ "The extracted grammars are written in the same folder as the"
     ++ "extraction grammar)."