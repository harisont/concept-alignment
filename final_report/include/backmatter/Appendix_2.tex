\chapter{Installing, using and configuring the CA module} \label{b}
This appendix provides installation and usage instructions for the CA software developed as part of this thesis project, whose source code, as well as this report, is available at \url{github.com/harisont/concept-alignment}.

\section{Installation}
To compile the CA module, we recommend the Haskell Stack\footnote{\url{https://docs.haskellstack.org/en/stable/README/}}. 
To build the project, clone the above mentioned GitHub repository, move into the corresponding directory and run \texttt{stack build}. 
This will generate a haskell library, named \texttt{concept-alignment}, and the following five executables: \smallskip

\begin{itemize}
    \item \texttt{extract-concepts}, the CE module described in Section \ref{ch3}
    \item \texttt{propagate-concepts}, the CP module described in Section \ref{ch4}
    \item \texttt{evalign}, a script for evaluating CP and CE
    \item \texttt{generate-grammar}, for automatically generating a grammar as described in Section \ref{grgn}
    \item \texttt{translate}, the simple MT module presented in Section \ref{mt}
\end{itemize}

\section{Usage}
\subsection{\texttt{extract-concepts}}
Using the CE module with the default parameters is straightforward: \smallskip

\begin{verbatim}
    stack exec -- extract-concepts SL.conllu TL.conllu
\end{verbatim} \smallskip

The program, however, supports a number of command-line options. Most importantly:
\begin{itemize}
    \item \texttt{--file=FILE} can be used to specify where to write the resulting alignments. Unless otherwise specified (see below), the output consists in two new aligned \texttt{.conllu} files, stored at the chosen location, whose names are prefixed with \texttt{SL} and \texttt{TL} respectively
    \item \texttt{--linearize} specifies that concepts should be in the linearized format described in Section \ref{evalign}, useful for evaluation purposes
    \item \texttt{--maxsize=INT} sets the maximum size of the extracted alignments
    \item \texttt{--all} specifies that the selection step described in Section \ref{select} should be skipped
    \item \texttt{--clauses} enables clause segmentation (cf. Section \ref{clauses})
    \item \texttt{--rest} enables a second pass of alignment ``by exclusion'' (cf. Section \ref{exclusion}) 
    \item \texttt{--pharaoh=FILE} is used to specify a file in pharaoh format (cf. Figure \ref{wordalgn}) to use as backup
\end{itemize}

\subsection{\texttt{propagate-concepts}}
CP requires two, instead of three, \texttt{.conllu} files, one with the concepts to propagate and the following two containing the corpus of annotated sentences where their should be looked for. As a consequence, running it with the default parameters should be done as follows: \smallskip

\begin{verbatim}
    stack exec -- propagate-concepts SL_concepts.conllu SL.conllu 
    TL.conllu
\end{verbatim} \smallskip

All \texttt{extract-concepts} options that are also relevant for CP (i.e. all of them excepts \texttt{--maxsize} and \texttt{pharaoh}) are also valid for this second executable.

\subsection{\texttt{evalign}}
The evaluation scrip \texttt{evalign} can be run in three different ``modes'': \smallskip

\begin{enumerate}
    \item single-file mode (\texttt{stack exec -- evalign annotated.txt}): given a pre-annotated file in the linearized format described in Section \ref{evalign}, it prints out basic statistics about precision, recall and amount of reusable alignments.
    \item extraction interactive mode (\texttt{stack exec -- evalign extraction annotated.txt new.txt}): given an annotated and a new, possibly yet-to-annotate file containing linearized alignments, it allows interactive minimal annotation of the latter (if needed) and, on top of printing out the basic statitics, it compares the new alignments to the old ones, telling how many correct and incorrect alignments were lost and/or found
    \item propagation interactive mode (\texttt{stack exec -- evalign propagation annotated.ca new.ca}): similar to extraction interactive mode, excepts that the statistics are CP-specific (percentage of successfully propagated alignments, number of errors introduced by CP etc.)
\end{enumerate} \smallskip

The command line option \texttt{--reasons} can be used when criterion-wise statistics are needed.

\subsection{\texttt{generate-grammar}}
The grammar generation module can be run as follows: \smallskip

\begin{verbatim}
    stack exec -- GenerateGrammar path_to_extract_grammar 
    paths_to_morphodicts paths_to_aligned_conllu_files
\end{verbatim} \smallskip

Here, \texttt{path\_to\_extract\_grammar} should point to the extraction grammar in \texttt{.pgf}\footnote{Portable Grammar Format, generated by the GF compiler.} format. \texttt{paths\_to\_morphodicts} stands for the path of the morphological dictionaries of the languages involved, also in \texttt{.pgf} format. Similarly, \texttt{paths\_to\_aligned\_conllu\_files} is to be replaced with the files containing the concepts in CoNNL-u format. These files should be, in terms of the languages they are written in, in the same order as the morphological dictionaries.

\subsection{\texttt{translate}}
The simplicity of the translation module makes it also extremely easy to use. The string or list of newline-separate strings to translate comes from the standard input and the only argument is the path to the automatically generated GF grammar to be used, again in \texttt{.pgf} format. Here is an example of using the program to translate a single sentence: \smallskip

\begin{verbatim}
    echo "this sentence will be translated" | stack exec -- translate
    Extracted.pgf             
\end{verbatim}

\section{Configuration: modifying the alignment criteria}
As mentioned in Section \ref{criteria}, modifying the alignment criteria the program makes use of requires little effort. 
All criteria are in fact defined in a separate Haskell module \texttt{Criteria}\footnote{\url{https://github.com/harisont/concept-alignment/blob/master/Criteria.hs}} that exports only the list of criteria to be used. 
In the current implementation, it looks like this: \smallskip

\begin{lstlisting}
    criteria :: [Criterion]
    criteria = [udpos, ud, divs, pass, pos]
\end{lstlisting}

Removing and/or changing the priority of the criteria is then just a matter of altering such list. \smallskip

Adding new criteria is also simple, but it requires an understanding of the data type \texttt{Criterion}, defined in module \texttt{ConceptAlignment}:

\begin{lstlisting}
    data Criterion = C {
        func :: UDTree -> UDTree -> Bool, 
        reas :: S.Set Reason,
        headAlign :: Bool,
        strict :: Bool
}
\end{lstlisting}

As the above code block shows, \texttt{Criterion} is a record type whose fields are:

\begin{itemize}
    \item a boolean function \texttt{func} specifying a rule to decide whether two trees should be aligned. For instance Criterion \ref{udmatch} (UD label matching) is implemented as
    \begin{lstlisting}
        udMatch :: UDTree -> UDTree -> Bool
        (RTree n ts) `udMatch` (RTree m us) = 
            udDEPREL n == udDEPREL m
    \end{lstlisting}
    \item a set of \texttt{Reason} \texttt{reas} to be used for ranking the alignments, shown in the linearized files and used to compute criterion-specific statistics. Reasons, and not alignment rules (\texttt{func}s), are what mirrors criteria as defined in Section \ref{criteria} exactly. A \texttt{func} can define in fact a more specific alignment rule, such as ``type of categorial divergence in which an adjective is replaced by adverb'', while a \texttt{Reason} is in practice a more coarse-grained label associated to potentially many rules
    \item two boolean flags, \texttt{headAlign} and \texttt{strict}, the former specifying whether head alignment should be performed for UD tree pairs matching that criterion, the latter marking the criterion as either strict (i.e. to be also used for ``alignment by exclusion'', cf. Section \ref{exclusion}) or not.
\end{itemize}